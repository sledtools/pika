#!/usr/bin/env python3
"""Minimal local pi-adapter mock for Worker brain=pi flows.

API:
  POST /rpc
  POST /reply
  GET  /health
"""

import argparse
import json
import time
from http.server import BaseHTTPRequestHandler, ThreadingHTTPServer


class Handler(BaseHTTPRequestHandler):
    server_version = "pi-adapter-mock/0.2"

    def _json(self, status: int, payload: dict) -> None:
        body = json.dumps(payload).encode("utf-8")
        self._raw(status, "application/json; charset=utf-8", body)

    def _raw(self, status: int, content_type: str, body: bytes) -> None:
        self.send_response(status)
        self.send_header("Content-Type", content_type)
        self.send_header("Content-Length", str(len(body)))
        self.end_headers()
        self.wfile.write(body)

    def do_GET(self):
        if self.path == "/health":
            self._json(200, {"ok": True, "service": "pi-adapter-mock"})
            return
        self._json(404, {"error": "not found"})

    def do_POST(self):
        if self.path not in ("/reply", "/rpc"):
            self._json(404, {"error": "not found"})
            return

        content_len = int(self.headers.get("content-length", "0"))
        raw = self.rfile.read(content_len) if content_len > 0 else b"{}"
        try:
            data = json.loads(raw.decode("utf-8"))
        except Exception as exc:
            self._json(400, {"error": f"invalid json: {exc}"})
            return

        agent_id = str(data.get("agent_id", "agent")).strip() or "agent"
        rpc = data.get("rpc")
        rpc_message = ""
        if isinstance(rpc, dict):
            rpc_message = str(rpc.get("message", "")).strip()

        message = rpc_message or str(data.get("message", "")).strip()
        if not message:
            self._json(400, {"error": "message is required"})
            return

        history = data.get("history")
        turn = 1
        if isinstance(history, list):
            turn = sum(1 for entry in history if isinstance(entry, dict) and entry.get("role") == "assistant") + 1

        reply = f"pi-adapter({turn})[{agent_id}]: {message}"
        reply_delay_ms = int(getattr(self.server, "reply_delay_ms", 0) or 0)
        if reply_delay_ms > 0:
            time.sleep(reply_delay_ms / 1000.0)
        if self.path == "/rpc":
            rpc_mode = getattr(self.server, "rpc_mode", "events")
            if rpc_mode == "disabled":
                self._json(405, {"error": "rpc disabled"})
                return

            events = [
                {
                    "type": "message_update",
                    "assistantMessageEvent": {
                        "type": "text_delta",
                        "delta": reply,
                    },
                },
                {"type": "agent_end"},
            ]

            if rpc_mode == "events":
                self._json(200, {"events": events})
                return

            if rpc_mode == "ndjson":
                body = "".join(json.dumps(event) + "\n" for event in events).encode("utf-8")
                self._raw(200, "application/x-ndjson; charset=utf-8", body)
                return

            if rpc_mode == "sse":
                chunks = []
                for event in events:
                    chunks.append(f"data: {json.dumps(event)}\n\n")
                chunks.append("data: [DONE]\n\n")
                self._raw(200, "text/event-stream; charset=utf-8", "".join(chunks).encode("utf-8"))
                return

            self._json(500, {"error": f"unsupported rpc mode: {rpc_mode}"})
            return

        self._json(200, {"reply": reply})

    def log_message(self, format, *args):
        # Keep output terse; rely on caller logs when needed.
        return


def main() -> int:
    parser = argparse.ArgumentParser(description="Run a local pi-adapter mock server")
    parser.add_argument("--host", default="127.0.0.1")
    parser.add_argument("--port", type=int, default=8788)
    parser.add_argument(
        "--rpc-mode",
        choices=("events", "ndjson", "sse", "disabled"),
        default="events",
        help="Response shape used by /rpc endpoint",
    )
    parser.add_argument(
        "--reply-delay-ms",
        type=int,
        default=0,
        help="Delay each /rpc or /reply response by this many milliseconds",
    )
    args = parser.parse_args()

    server = ThreadingHTTPServer((args.host, args.port), Handler)
    server.rpc_mode = args.rpc_mode
    server.reply_delay_ms = max(0, args.reply_delay_ms)
    print(
        f"pi-adapter-mock listening on http://{args.host}:{args.port} (rpc_mode={args.rpc_mode}, reply_delay_ms={server.reply_delay_ms})",
        flush=True,
    )
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        pass
    finally:
        server.server_close()
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
